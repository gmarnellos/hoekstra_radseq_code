'''AMOS.py utility module for handling assembly-related tasks

'''
import os, sys, re, subprocess, math, Seq, GFF, Aln
from copy import deepcopy

def get_scaff_from_minimus(contig):
	'''takes <contig> filename, returns GFF.File of scaffolding, e.g.
	
	LS146000       .       .       1       946     .       -       .       contig_end=1904;contig=8;contig_start=1004
	'''

	contigs = GFF.File()
	
	for l in open(contig):
		match = re.search('#(?P<seqid>.+?)\(\d+\)\s(?P<strand>.+?)\s.+?\{(?P<sstart>\d+)\s(?P<send>\d+)\}\s\<(?P<cstart>\d+)\s(?P<cend>\d+)\>',l)
		if l.startswith('##'):
			num = l.split()[0][2:]
		elif match:
			m = match.groupdict()
			r = GFF.Region()
			r['seqid'] = m['seqid']
			r['start'],r['end'] = [str(s) for s in sorted((int(m['sstart']),int(m['send'])))]
			r['attribute_contig'] = num
			r['attribute_cstart'],r['attribute_cend'] = [str(s) for s in sorted((int(m['cstart']),int(m['cend'])))]
			if m['strand'] == '[RC]':
				r['strand'] = '-'
			else:
				r['strand'] = '+'
			contigs.append(r)
	return contigs
			
def build_fasta_from_scaff_gff(infasta_s,gff,contig_prefix='',include_singletons=True,ol_minID=0.9,outfile=None,mum_len='4'):
	'''takes scaffolding information from gff of the form generated by get_scaff_from_minimus
	builds a single assembly for all scaffold instructions pertaining to seqids in infasta
	
	if include_singletons is True, adds all sequences from infasta not included in scaffolds along with the scaffolded sequence in the returned assembly
	
	ol_minID is the minimum %ID accepted for overlaps in contigs
	'''
	
	if isinstance(infasta_s,str):
		infasta = Seq.Fasta(infasta_s)
	else:
		infasta = deepcopy(infasta_s)
	
	suffixes = ['','b','c','d','e','f']
	current_suffix = ''
	
	#use only scaffolding info relevant to the specified infasta
	in_ids = infasta.seq_names()
	this_gff = [r for r in gff if r['seqid'] in in_ids]
	
	#use only scaffolding info that joins 2 or more seqs
	contigs = {}.fromkeys([r['attribute_contig'] for r in this_gff],0)
	for r in this_gff:
		contigs[r['attribute_contig']] += 1

	#get final ordered scaffolding layout
	this_gff = sorted([r for r in this_gff if contigs[r['attribute_contig']] > 1],
					key=lambda r: (r['attribute_contig'],int(r['attribute_cstart']),int(r['attribute_cend'])))
	
	#extract sequences and orient for scaffolding
	assem_frags = infasta.substr_from_gff(this_gff,plus_strand=True,name_key=None)

	assem = Seq.Fasta()
	for k,v in contigs.items():
		if v>1:
			assem[contig_prefix+k] = Seq.Sequence('')

	if this_gff:
		for i,r in enumerate(this_gff[:-1]):
			next = this_gff[i+1]
			if r['attribute_contig'] == next['attribute_contig']:
				s1,e1,s2,e2 = [int(n) for n in [r['attribute_cstart'],r['attribute_cend'],next['attribute_cstart'],next['attribute_cend']]]
				print >> sys.stderr, 'scaffolding %s %s %s %s:\n\t%s\n\t%s' % (s1,e1,s2,e2,r,next)
			
				if e1 > s2:
					print >> sys.stderr, 'OVERLAP:\n\t%s\n\t%s' % (assem_frags[r['seqid']][(s2-s1):],assem_frags[next['seqid']][:(e1-s2+1)])
					fa1 = Seq.Fasta()
					fa2 = Seq.Fasta()
					fa1['seq1'] = assem_frags[r['seqid']][(s2-s1):]
					fa2['seq2'] = assem_frags[next['seqid']][:(e1-s2+1)]
					shorter = min(len(fa1['seq1']),len(fa2['seq2']))
					mums = Aln.mum(fa1,fa2,mumargs={'-l':'%s' % int(mum_len)})[0]
					match = float(sum([mumr['score'] for mumr in mums]))
					if (shorter <= 2*int(mum_len) + math.ceil((1-ol_minID)*shorter)) or \
							(match/shorter >= ol_minID) or \
							(fa1['seq1'][:shorter] == fa2['seq2'][:shorter]) or \
							(Seq.is_simple(fa1['seq1']) or Seq.is_simple(fa2['seq2'])):
						assem[contig_prefix+r['attribute_contig']+current_suffix] += assem_frags[r['seqid']][:s2]
					else:
						#implement record of splitting into a/b/etc fragments!
						print >> sys.stdout,fa1,'\n',fa2,'\n',mums
						current_suffix = suffixes[suffixes.index(current_suffix)+1]
						print >>sys.stderr, 'overlap of %s bp %0.2f %%id unresolved (min %0.2f)\nstarting %s' % (e1-s2,match/(e1-s2),ol_minID,current_suffix)
						assem[contig_prefix+r['attribute_contig']+current_suffix] = assem_frags[r['seqid']]
				else:
					spacer = Seq.Sequence('n'*(s2-e1))
					assem[contig_prefix+r['attribute_contig']+current_suffix] += assem_frags[r['seqid']] + spacer
			else:
				assem[contig_prefix+r['attribute_contig']+current_suffix] += assem_frags[r['seqid']]
				current_suffix = ''
	
		assem[contig_prefix+this_gff[-1]['attribute_contig']+current_suffix] += assem_frags[this_gff[-1]['seqid']]
	
	if include_singletons:
		singletons = dict([(k,v) for k,v in infasta.items() if not k in [r['seqid'] for r in this_gff]])
		assem.update(singletons)

	if outfile:
		assem.write_to_file(outfile)
		
	return assem

def run_minimus2(fasta1,fasta2,outroot,comp_scaff_dir=None,catfile=None,contig_prefix=None):
	'''given 2 fasta files, produces a minimus2 merged assembly with contigs prefixed by <contig_prefix>.

	N.B. for minimus2 outroot is dir, not filebase
	
	if comp_scaff_dir is supplied, also generates fasta output with sequence from each source separately,
	scaffolded per minimus2 assembly with Ns.  Then puts each species scaffold in its own dir under comp_scaff_dir
	
	returns filename of final assembly'''

	try:
		os.makedirs(outroot)
	except:
		pass
		
	cat_prefix = lambda x: os.path.split(x)[-1].split('.')[0]
	
	seq_counts = dict([l.strip().split(':') for l in subprocess.Popen('grep -c ">" %s %s' % (fasta1,fasta2),stdout=subprocess.PIPE,shell=True).stdout.readlines()])

	if catfile is None:
		catfile = os.path.join(outroot,'%s-%s.cat.fa' % (cat_prefix(fasta1), cat_prefix(fasta2)))
		base_end = -7
	else:
		base_end = catfile.rfind('.')

	os.system('cat %s %s > %s' % (fasta1,fasta2,catfile))
	os.system('toAmos -s %s -o %s.afg' % (catfile,catfile[:base_end]))
	
	os.system('minimus2 %s REFCOUNT=%s' % (catfile[:base_end],seq_counts[fasta1]))

	min2_assem = catfile[:base_end]+'.fasta'
	min2_contig = catfile[:base_end]+'.contig'

	if contig_prefix:		
		lines = open(min2_contig).readlines()
		fh = open(min2_contig,'w')
		for l in lines:
			if l.startswith('##'):
				print >> fh, '##'+contig_prefix+l[2:],
			else:
				print >> fh, l,
		fh.close()
		lines = open(min2_assem).readlines()
		fh = open(min2_assem,'w')
		for l in lines:
			if l.startswith('>'):
				print >> fh, '>'+contig_prefix+l[1:],
			else:
				print >> fh, l,
		fh.close()		
	
	if comp_scaff_dir:
		scaff_gff = get_scaff_from_minimus(catfile[:base_end]+'.contig')
		#generate fasta1 scaffolds based on fasta2
		outfile = os.path.join(outroot,'%s.%sxscaff.all.fasta' % (cat_prefix(fasta1),cat_prefix(fasta2)))
		build_fasta_from_scaff_gff(fasta1,scaff_gff,contig_prefix='%s_%sxscaff' % (cat_prefix(fasta1),cat_prefix(fasta2)), outfile=outfile)
		#generate fasta2 scaffolds based on fasta1
		outfile = os.path.join(outroot,'%s.%sxscaff.all.fasta' % (cat_prefix(fasta2),cat_prefix(fasta1)))
		build_fasta_from_scaff_gff(fasta2,scaff_gff,contig_prefix='%s_%sxscaff' % (cat_prefix(fasta2),cat_prefix(fasta1)), outfile=outfile)
		
		#copy single-source scaffolds to appropriate subdir in comp_scaff_dir
		for fn in (fasta1,fasta2):
			sp = cat_prefix(fn)
			this_xscaffdir = os.path.join(comp_scaff_dir,sp)
			try:
				os.makedirs(this_xscaffdir)
			except:
				pass
			os.system('cp %s %s' % (os.path.join(outroot,sp+'*xscaff*'),this_xscaffdir))
	
	return min2_assem
	
def run_minimus(fasta,outroot=None,restore_singletons=True,contig_prefix='',qual=None):
	'''given a fasta file and an optional output root (otherwise use fasta base)
	
	generates an assembly using minimus from the amos package
	assembly saved as <outroot>.minimus.fasta
	optionally restores singleton reads in <outroot>.all.fasta
	if restore_singletons=True, returns path to .all.fasta, otherwise returns path to minimus.fasta'''
	
	if outroot is None:
		outroot = fasta.rsplit('.',1)[0]

	if qual:
		print >> sys.stderr, 'qualities invoked (%s)' % qual
		os.system('toAmos -s %s -q %s -o %s.afg' % (fasta, qual, outroot))
	else:
		os.system('toAmos -s %s -o %s.afg' % (fasta,outroot))
	os.system('minimus -D TGT=%s.afg %s.minimus' % (outroot,outroot))

	if contig_prefix:
		lines = open(outroot+'.minimus.contig').readlines()
		fh = open(outroot+'.minimus.contig','w')
		for l in lines:
			if l.startswith('##'):
				print >> fh, '##'+contig_prefix+l[2:],
			else:
				print >> fh, l,
		fh.close()
	
	if restore_singletons:
		in_assem = re.findall('#(.+?)\(',open(outroot+'.minimus.contig').read())
		reads = Seq.Fasta(fasta)
		for f in in_assem:
			del reads[f]
		all_fasta = outroot+'.all.fasta'
		assem = Seq.Fasta(outroot+'.minimus.fasta')
		allseq=Seq.Fasta()
		allseq.update(dict([(contig_prefix+k,v) for k,v in assem.items()]))
		allseq.update(reads)
		allseq.write_to_file(all_fasta)
		return all_fasta
	else:
		if contig_prefix:
			f = outroot+'.minimus.fasta'
			lines = open(f).readlines()
			fh = open(f,'w')
			for l in lines:
				if l.startswith('>'):
					print >> fh, '>'+contig_prefix+l[1:],
				else:
					print >> fh, l,
			fh.close()
		return outroot+'.minimus.fasta'
		
